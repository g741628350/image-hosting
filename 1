import warnings
warnings.filterwarnings("ignore")
from functools import wraps
from threading import Thread
import os
import pandas as pd
import configparser
from PyQt5 import QtWidgets, QtCore
from PyQt5.QtCore import QObject, pyqtSignal
from PyQt5.QtWidgets import QDialog, QMessageBox
import time
import threading
import concurrent.futures

# 配置文件路径
CONFIG_FILE = 'config.ini'

class TimeoutError(Exception):
    pass

def timeout(seconds=10):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            result = []
            def target():
                try:
                    result.append(func(*args, **kwargs))
                except Exception as e:
                    result.append(e)
            
            thread = Thread(target=target)
            thread.start()
            thread.join(seconds)
            
            if thread.is_alive():
                raise TimeoutError(f"Timeout after {seconds} seconds")
            elif isinstance(result[0], Exception):
                raise result[0]
            return result[0]
        return wrapper
    return decorator

class FilePathSelectionDialog(QtWidgets.QDialog):
    def __init__(self, initial_path=""):
        super().__init__()
        self.setWindowTitle("选择文件路径")
        self.setGeometry(100, 100, 400, 150)
        self.setWindowFlags(QtCore.Qt.FramelessWindowHint)

        # 添加拖动相关的属性
        self.is_dragging = False
        self.drag_position = None

        # 创建标题栏
        title_bar = QtWidgets.QWidget()
        title_bar.setFixedHeight(30)
        title_bar.setStyleSheet("background-color: #2b2b2b;")

        title_layout = QtWidgets.QHBoxLayout(title_bar)
        title_layout.setContentsMargins(10, 0, 0, 0)

        # 添加标题文本
        title_label = QtWidgets.QLabel("选择文件路径")
        title_label.setStyleSheet("color: white; font-size: 12px;")
        title_layout.addWidget(title_label)

        # 创建输入框和按钮
        self.file_path_input = QtWidgets.QLineEdit(self)
        self.file_path_input.setPlaceholderText("请输入文件路径")
        self.file_path_input.setText(initial_path)

        self.browse_button = QtWidgets.QPushButton("浏览", self)
        self.browse_button.clicked.connect(self.browse_file)

        self.confirm_button = QtWidgets.QPushButton("确认", self)
        self.confirm_button.clicked.connect(self.confirm_path)

        # 布局
        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)  # 设置布局边距为0
        layout.setSpacing(0)  # 设置布局间距为0

        # 创建内容容器
        content = QtWidgets.QWidget()
        content_layout = QtWidgets.QVBoxLayout(content)
        content_layout.setContentsMargins(10, 10, 10, 10)

        content_layout.addWidget(self.file_path_input)
        content_layout.addWidget(self.browse_button)
        content_layout.addWidget(self.confirm_button)

        # 添加标题栏和内容到主布局
        layout.addWidget(title_bar)
        layout.addWidget(content)

        # 应用样式表
        self.setStyleSheet(
            """ 
            QWidget {
                background-color: #333333;
                color: white;
                font-family: Arial, sans-serif;
            }
            QLineEdit {
                background-color: #404040;
                border: 1px solid #555555;
                padding: 5px;
                border-radius: 3px;
            }
            QPushButton {
                background-color: #0078D7;
                color: white;
                border: none;
                padding: 8px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #1884D7;
            }
        """
        )

    def browse_file(self):
        folder = QtWidgets.QFileDialog.getExistingDirectory(self, "选择文件夹")
        if folder:
            self.file_path_input.setText(folder)

    def confirm_path(self):
        folder_path = self.file_path_input.text().strip()
        if os.path.exists(folder_path):
            self.accept()  # 关闭对话框并返回成功
        else:
            QtWidgets.QMessageBox.warning(self, "错误", "路径无效，请重新输入。")

    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.LeftButton:
            if event.pos().y() <= 30:  # 只在标题栏区域响应拖动
                self.is_dragging = True
                self.drag_position = event.globalPos() - self.frameGeometry().topLeft()

    def mouseMoveEvent(self, event):
        if self.is_dragging:
            self.move(event.globalPos() - self.drag_position)

    def mouseReleaseEvent(self, event):
        if event.button() == QtCore.Qt.LeftButton:
            self.is_dragging = False


class LineConfigDialog(QtWidgets.QDialog):
    def __init__(self, lines_dict):
        super().__init__()
        self.setWindowTitle("线别配置")
        self.setGeometry(100, 100, 500, 400)
        self.lines_dict = lines_dict.copy()
        
        # 创建布局
        layout = QtWidgets.QVBoxLayout(self)
        
        # 创建表格
        self.table = QtWidgets.QTableWidget()
        self.table.setColumnCount(2)
        self.table.setHorizontalHeaderLabels(['线别', '路径'])
        
        # 设置表格表头样式
        self.table.horizontalHeader().setStyleSheet("""
            QHeaderView {
                background-color: #333333;
            }
            QHeaderView::section {
                background-color: #333333;
                color: white;
                padding: 5px;
                border: 1px solid #555555;
            }
        """)
        
        self.table.verticalHeader().setStyleSheet("""
            QHeaderView, QHeaderView::section {
                background-color: #333333;
                color: white;
                border: 1px solid #555555;
            }
        """)
        
        # 设置表格样式
        self.table.setStyleSheet("""
            QTableWidget {
                background-color: #404040;
                border: 1px solid #555555;
                gridline-color: #555555;
            }
            QTableWidget::item {
                color: white;
            }
        """)
        
        self.refresh_table()
        
        # 添加/删除按钮
        btn_layout = QtWidgets.QHBoxLayout()
        add_btn = QtWidgets.QPushButton("添加线别")
        del_btn = QtWidgets.QPushButton("删除选中")
        add_btn.clicked.connect(self.add_line)
        del_btn.clicked.connect(self.delete_line)
        
        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(del_btn)
        
        # 确认/取消按钮
        dialog_btns = QtWidgets.QHBoxLayout()
        confirm_btn = QtWidgets.QPushButton("确认")
        cancel_btn = QtWidgets.QPushButton("取消")
        confirm_btn.clicked.connect(self.accept)
        cancel_btn.clicked.connect(self.reject)
        
        dialog_btns.addWidget(confirm_btn)
        dialog_btns.addWidget(cancel_btn)
        
        layout.addWidget(self.table)
        layout.addLayout(btn_layout)
        layout.addLayout(dialog_btns)
        
        # 应用样式
        self.setStyleSheet("""
            QDialog {
                background-color: #333333;
                color: white;
            }
            QTableWidget {
                background-color: #404040;
                color: white;
                border: 1px solid #555555;
            }
            QPushButton {
                background-color: #0078D7;
                color: white;
                border: none;
                padding: 8px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #1884D7;
            }
        """)

    def refresh_table(self):
        self.table.setRowCount(len(self.lines_dict))
        self.table.verticalHeader().setVisible(False)  # 隐藏行头
        for i, (line, path) in enumerate(self.lines_dict.items()):
            self.table.setItem(i, 0, QtWidgets.QTableWidgetItem(line))
            self.table.setItem(i, 1, QtWidgets.QTableWidgetItem(path))

    def add_line(self):
        dialog = FilePathSelectionDialog()
        if dialog.exec_() == QtWidgets.QDialog.Accepted:
            path = dialog.file_path_input.text().strip()
            line_name, ok = QtWidgets.QInputDialog.getText(self, "输入线别", "请输入线别名称:")
            if ok and line_name:
                self.lines_dict[line_name] = path
                self.refresh_table()

    def delete_line(self):
        current_row = self.table.currentRow()
        if current_row >= 0:
            line = self.table.item(current_row, 0).text()
            del self.lines_dict[line]
            self.refresh_table()


class QueryWorker(QObject):
    finished = pyqtSignal()
    progress = pyqtSignal(int)
    result = pyqtSignal(dict)
    error = pyqtSignal(str)
    status_update = pyqtSignal(str)  # 新增状态更新信号

    def __init__(self):
        super().__init__()
        self._is_cancelled = False
        self._lock = threading.RLock()  # 使用可重入锁
        self.results = []
        self._start_time = None
        self._processed_count = 0
        self._total_count = 0
        self._executor = None  # 保存executor引用用于清理

    def cancel(self):
        """安全地取消操作"""
        with self._lock:
            self._is_cancelled = True
            # 立即取消线程池中的任务
            if self._executor:
                try:
                    self._executor.shutdown(wait=False)
                except Exception as e:
                    print(f"取消线程池时出错: {str(e)}")

    def _check_cancelled(self):
        """检查是否被取消"""
        with self._lock:
            return self._is_cancelled

    def _update_progress(self, current: int, total: int, message: str = ""):
        """更新进度，针对大量文件优化"""
        if total <= 0:
            return

        progress = int((current / total) * 100)

        # 只在进度有明显变化时才更新UI（提高阈值）
        if not hasattr(self, '_last_progress') or abs(progress - self._last_progress) >= 5:
            self.progress.emit(progress)
            self._last_progress = progress

        # 大幅减少状态消息更新频率
        if current % 1000 == 0 or current == total:
            status_msg = f"{message} {current}/{total}"
            self.status_update.emit(status_msg)
            
    def _scan_directory(self, path, start_timestamp, end_timestamp):
        """高性能目录扫描函数，针对大量文件优化"""
        try:
            files = []

            scanned_count = 0
            matched_count = 0

            # 检测是否为网络路径
            network_path = is_network_path(path)

            # 创建线程池（虽然现在不使用，但保持接口一致性）
            max_workers = 2 if network_path else 4
            self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=max_workers)

            try:

                # 获取目录快照，直接应用时间过滤
                directory_snapshot = self._get_directory_snapshot(path, start_timestamp, end_timestamp)
                total_otr_files = len(directory_snapshot)
                self._total_count = total_otr_files
                self._start_time = time.time()

                self.status_update.emit(f"开始处理 {total_otr_files} 个符合时间条件的文件...")

                # 检查是否有文件需要处理
                if total_otr_files == 0:
                    self.status_update.emit("未找到符合时间条件的 .otr 文件")
                    return []

                # 由于已经在_get_directory_snapshot中进行了时间过滤，
                # 这里不需要再次进行时间检查，直接返回所有文件
                for file_path in directory_snapshot:
                    if self._check_cancelled():
                        return []

                    scanned_count += 1
                    matched_count += 1  # 所有文件都已经通过时间过滤
                    files.append(file_path)

                    # 减少进度更新频率
                    if scanned_count % 1000 == 0:
                        self.status_update.emit(f"正在处理第 {scanned_count}/{total_otr_files} 个文件")
                        self._update_progress(scanned_count, total_otr_files, "处理文件")
                        # 强制处理UI事件，保持响应
                        QtWidgets.QApplication.processEvents()

            finally:
                # 确保线程池被正确关闭
                if self._executor:
                    try:
                        self._executor.shutdown(wait=False)  # 不等待，快速关闭
                    except Exception:
                        pass
                    finally:
                        self._executor = None

            # 简化结果报告
            self.status_update.emit(f"扫描完成: 处理{scanned_count}个文件，匹配{matched_count}个")

            return files

        except Exception as e:
            error_msg = f"扫描目录出错: {str(e)}"
            self.status_update.emit(error_msg)
            return []
            
    def _get_directory_snapshot(self, path, start_timestamp=None, end_timestamp=None):
        """获取目录快照，修复无限循环问题"""
        files = []
        file_count = 0
        filtered_count = 0
        max_files = 10000  # 降低文件数限制，避免内存问题
        progress_interval = 500  # 更频繁的进度更新，让用户知道程序在工作
        max_scan_count = 100000  # 设置最大扫描文件数，防止无限循环

        try:
            self.status_update.emit("正在扫描目录结构...")

            # 使用更安全的目录遍历方式，避免符号链接问题
            visited_dirs = set()  # 记录已访问的目录，避免循环引用

            for root, dirs, filenames in os.walk(path, followlinks=False):  # 不跟随符号链接
                if self._check_cancelled():
                    break

                # 防止无限循环：检查是否已访问过这个目录
                real_root = os.path.realpath(root)
                if real_root in visited_dirs:
                    continue
                visited_dirs.add(real_root)

                # 严格限制扫描深度
                depth = root[len(path):].count(os.sep)
                if depth >= 5:  # 大幅降低深度限制
                    dirs[:] = []
                    continue

                # 过滤出.otr文件，减少后续处理
                otr_files = [f for f in filenames if f.endswith('.otr')]

                for filename in otr_files:
                    if self._check_cancelled():
                        break

                    file_count += 1

                    # 防止无限循环：设置最大扫描数量
                    if file_count > max_scan_count:
                        self.status_update.emit(f"扫描文件数量过多({file_count})，停止扫描以避免系统问题")
                        break

                    # 更频繁的进度更新
                    if file_count % progress_interval == 0:
                        if start_timestamp is not None:
                            self.status_update.emit(f"已扫描 {file_count} 个文件，筛选出 {filtered_count} 个...")
                        else:
                            self.status_update.emit(f"已发现 {file_count} 个文件...")
                        # 强制处理UI事件，保持响应
                        QtWidgets.QApplication.processEvents()

                    file_path = os.path.join(root, filename)

                    # 如果提供了时间范围，进行时间过滤
                    if start_timestamp is not None and end_timestamp is not None:
                        try:
                            file_stats = os.stat(file_path)
                            file_timestamp = file_stats.st_mtime

                            # 只有在时间范围内的文件才添加
                            if start_timestamp <= file_timestamp <= end_timestamp:
                                files.append(file_path)
                                filtered_count += 1
                        except (OSError, PermissionError):
                            continue
                    else:
                        # 没有时间过滤，直接添加
                        try:
                            files.append(file_path)
                            filtered_count += 1
                        except (OSError, PermissionError):
                            continue

                    # 如果文件数量达到限制，停止扫描
                    if len(files) >= max_files:
                        self.status_update.emit(f"已收集足够文件({len(files)})，停止扫描")
                        break

                    # 定期检查取消状态
                    if file_count % 1000 == 0:
                        if self._check_cancelled():
                            break

                # 如果达到文件数量限制或扫描数量限制，跳出外层循环
                if len(files) >= max_files or file_count > max_scan_count:
                    break

            if start_timestamp is not None:
                self.status_update.emit(f"目录扫描完成，从 {file_count} 个文件中筛选出 {len(files)} 个符合时间条件的文件")
            else:
                self.status_update.emit(f"目录扫描完成，找到 {len(files)} 个文件")

            return files

        except Exception as e:
            error_msg = f"获取目录快照失败: {str(e)}"
            self.status_update.emit(error_msg)
            return []

    def _list_directory_safe(self, directory):
        """安全的目录列表获取，处理活跃目录"""
        try:
            # 多次尝试获取目录列表，处理文件正在创建/删除的情况
            for attempt in range(3):
                try:
                    items = os.listdir(directory)
                    return items
                except (FileNotFoundError, PermissionError, OSError) as e:
                    if attempt == 2:  # 最后一次尝试
                        raise e
                    time.sleep(0.1)  # 短暂等待后重试
            return []
        except Exception as e:
            print(f"无法列出目录内容 {directory}: {str(e)}")
            return []

    def _check_file_safe(self, file_path, start_timestamp, end_timestamp, timeout=1):
        """安全的文件检查，高性能版本"""
        try:
            # timeout参数保留用于接口兼容性
            return self._check_file_with_retry(file_path, start_timestamp, end_timestamp)
        except Exception:
            return None

    def _check_file_with_retry(self, file_path, start_timestamp, end_timestamp):
        """带重试机制的文件检查，使用时间戳比较"""
        max_retries = 2  # 减少重试次数

        for attempt in range(max_retries):
            try:
                # 快速检查文件是否存在
                if not os.path.exists(file_path):
                    return None

                # 简化文件锁定检查
                if attempt == 0 and self._is_file_locked_simple(file_path):
                    time.sleep(0.1)
                    continue

                # 获取文件时间信息
                file_stats = os.stat(file_path)
                file_timestamp = file_stats.st_mtime

                # 使用时间戳比较，更准确可靠
                if start_timestamp <= file_timestamp <= end_timestamp:
                    return file_path

                return None

            except (FileNotFoundError, PermissionError, OSError):
                if attempt < max_retries - 1:
                    time.sleep(0.05)  # 更短的等待时间
                    continue
                return None
            except Exception:
                return None

        return None

    def _is_file_locked_simple(self, file_path):
        """简化的文件锁定检查，提高性能"""
        try:
            # 简单的文件访问测试
            with open(file_path, 'rb') as f:
                f.read(1)  # 尝试读取1字节
            return False
        except (PermissionError, OSError):
            return True
        except Exception:
            return False

    def _check_file(self, file_path, start_timestamp, end_timestamp):
        """检查单个文件是否符合条件（保留原方法用于兼容）"""
        return self._check_file_safe(file_path, start_timestamp, end_timestamp)

    @timeout(2)  # 文件处理超时控制
    def _process_file(self, file_path):
        """处理单个文件"""
        try:
            # 首先检查文件是否存在
            if not os.path.exists(file_path):
                print(f"文件不存在: {file_path}")
                return None
                
            # 获取文件信息
            file_stats = os.stat(file_path)
            # 使用修改时间，在活跃目录中更可靠
            creation_time = time.strftime('%Y%m%d %H:%M',
                                        time.localtime(file_stats.st_mtime))
            
            return {
                'creation_time': creation_time,
                'size': file_stats.st_size,
                'modified_time': file_stats.st_mtime
            }
            
        except Exception as e:
            print(f"处理文件失败 {file_path}: {str(e)}")
            return None
            
    def do_query(self, path, material_code, start_timestamp, end_timestamp, position=None):
        """执行查询，针对大量文件优化版本"""
        try:
            # 重置状态
            self._is_cancelled = False
            self.results = []

            self.status_update.emit("开始查询...")

            # 扫描文件
            files = self._scan_directory(path, start_timestamp, end_timestamp)
            if not files:
                self.error.emit("未找到符合条件的文件")
                return

            total_files = len(files)
            processed = 0
            matched_files = 0

            self.status_update.emit(f"开始分析 {total_files} 个文件...")

            # 处理文件 - 针对大量文件优化
            for file_path in files:
                if self._check_cancelled():
                    return

                try:
                    file_info = self._process_file(file_path)
                    if file_info:
                        # 提取物料代码和位号
                        file_name = os.path.basename(file_path)
                        extracted_info = self.extract_info(file_name)

                        if extracted_info:
                            mat_code, pos = extracted_info

                            # 筛选逻辑（移除调试输出）
                            if (not material_code or mat_code == material_code) and \
                               (not position or pos == position):
                                matched_files += 1
                                self.results.append((mat_code, pos))

                except Exception:
                    continue

                processed += 1

                # 大幅减少进度更新频率，避免UI阻塞
                if processed % 500 == 0 or processed == total_files:
                    self.progress.emit(int((processed / total_files) * 100))

                # 定期更新状态并处理UI事件
                if processed % 2000 == 0:
                    self.status_update.emit(f"已分析 {processed}/{total_files} 个文件，匹配 {matched_files} 个")
                    # 强制处理UI事件，保持响应
                    QtWidgets.QApplication.processEvents()

            # 统计结果
            count_dict = {}
            for mat_code, pos in self.results:
                key = (mat_code, pos)
                count_dict[key] = count_dict.get(key, 0) + 1

            self.status_update.emit(f"查询完成: 处理{processed}个文件，匹配{matched_files}个")

            # 发送结果
            if not self._is_cancelled:
                self.result.emit(count_dict)

        except Exception as e:
            error_msg = f"查询过程发生错误: {str(e)}"
            self.error.emit(error_msg)
        finally:
            # 确保在所有情况下都发出完成信号
            self.finished.emit()

    @QtCore.pyqtSlot()
    def cleanup(self):
        """清理资源"""
        self.deleteLater()

    def extract_info(self, file_name):
        """从文件名中提取物料代码和位号
        文件名格式: 物料代码_位号_序号_时间戳.otr
        例如: 0800278_U201_1_20250123-120022.otr
        """
        try:
            # 分割文件名,去掉扩展名
            name_without_ext = os.path.splitext(file_name)[0]

            # 按下划线分割
            parts = name_without_ext.split('_')

            if len(parts) >= 4:  # 确保至少有4个部分
                material_code = parts[0]  # 第一部分是物料代码
                position = parts[1]       # 第二部分是位号
                return material_code, position

            return None, None

        except Exception:
            return None, None


class ProgressDialog(QDialog):
    cancelled = pyqtSignal()

    def __init__(self, worker=None, worker_thread=None):
        super().__init__()
        self.worker = worker
        self.worker_thread = worker_thread
        self.program_closing = False  # 添加标志

        # 针对大量文件处理优化界面
        self.setWindowTitle("处理中 - 请耐心等待")
        self.setFixedSize(400, 200)  # 增加窗口大小
        self.setWindowFlags(QtCore.Qt.Dialog | QtCore.Qt.FramelessWindowHint)

        layout = QtWidgets.QVBoxLayout(self)

        # 主状态标签
        self.status_label = QtWidgets.QLabel("正在处理文件...", self)
        self.status_label.setAlignment(QtCore.Qt.AlignCenter)

        # 进度条
        self.progress_bar = QtWidgets.QProgressBar(self)
        self.progress_bar.setTextVisible(True)
        self.progress_bar.setFormat("%p% (%v/%m)")  # 显示百分比和数值

        # 详细进度信息标签
        self.detail_label = QtWidgets.QLabel("准备开始扫描...", self)
        self.detail_label.setAlignment(QtCore.Qt.AlignCenter)
        self.detail_label.setWordWrap(True)  # 允许文本换行

        # 提示标签
        self.tip_label = QtWidgets.QLabel("处理大量文件需要时间，请不要关闭程序", self)
        self.tip_label.setAlignment(QtCore.Qt.AlignCenter)
        self.tip_label.setStyleSheet("color: #888888; font-size: 10px;")

        # 取消按钮
        self.cancel_button = QtWidgets.QPushButton("取消", self)
        self.cancel_button.clicked.connect(self.cancelled.emit)

        layout.addWidget(self.status_label)
        layout.addWidget(self.progress_bar)
        layout.addWidget(self.detail_label)
        layout.addWidget(self.tip_label)
        layout.addWidget(self.cancel_button)
        
        self.setStyleSheet("""
            QDialog {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
            }
            QLabel {
                color: white;
                padding: 5px;
            }
            QProgressBar {
                border: 1px solid #555555;
                border-radius: 3px;
                text-align: center;
                color: white;
                background-color: #404040;
                height: 25px;
                font-size: 12px;
            }
            QProgressBar::chunk {
                background-color: #0078D7;
                border-radius: 2px;
            }
            QPushButton {
                background-color: #0078D7;
                color: white;
                border: none;
                padding: 8px;
                border-radius: 3px;
                min-width: 80px;
            }
            QPushButton:hover {
                background-color: #1884D7;
            }
        """)
        
        # 连接进度信号（如果worker存在）
        if self.worker:
            self.worker.progress.connect(self.progress_bar.setValue)
            self.worker.status_update.connect(self.update_detail)

    def closeEvent(self, event):
        """只在用户手动关闭窗口且有任务运行时询问"""
        if not self.program_closing and self.worker_thread and self.worker_thread.isRunning():
            reply = QMessageBox.question(
                self, '确认关闭',
                '有正在进行的查询任务,确定要关闭吗?',
                QMessageBox.Yes | QMessageBox.No
            )
            if reply == QMessageBox.Yes:
                # 取消任务并关闭
                if self.worker:
                    self.worker.cancel()
                self.worker_thread.quit()
                self.worker_thread.wait()
                event.accept()
            else:
                event.ignore()
        else:
            # 程序主动关闭或没有运行中的任务,直接关闭
            event.accept()
            
    def close(self):
        """程序主动关闭时调用"""
        self.program_closing = True
        super().close()

    def confirm_cancel(self):
        """添加取消确认对话框"""
        reply = QMessageBox.question(
            self, '确认取消', 
            '确定要取消当前操作吗?',
            QMessageBox.Yes | QMessageBox.No
        )
        if reply == QMessageBox.Yes:
            self.cancelled.emit()
            
    def update_detail(self, message):
        """更新详细进度信息"""
        self.detail_label.setText(message)

    def connect_worker_signals(self):
        """连接worker信号"""
        if self.worker:
            self.worker.progress.connect(self.progress_bar.setValue)
            self.worker.status_update.connect(self.update_detail)
            # 重置进度条为正常模式
            self.progress_bar.setRange(0, 100)


class OTRStatisticsApp(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.lines_dict = self.load_config()  # 加载所有线别配置
        self.line_combo = QtWidgets.QComboBox()  # 提前创建line_combo
        self.setup_ui()  # 先创建UI
        
        # 如果没有配置，显示配置对话框
        if not self.lines_dict:
            if not self.show_line_config():
                self.close()
                return
        # 配置完成后更新下拉框
        self.line_combo.clear()
        self.line_combo.addItems(self.lines_dict.keys())

        # 修改线程相关的成员变量初始化
        self._worker = None
        self._worker_thread = None
        self._progress_dialog = None
        self._is_querying = False  # 添加查询状态标志

    def setup_ui(self):
        # 初始化导出数据
        self.export_data = None  # 用于存储要导出的数据

        # 初始化拖动和调整大小相关属性
        self.is_dragging = False
        self.drag_position = None
        self.resizing = False
        self.resize_edge = None
        self.resize_start_pos = None
        self.start_geometry = None
        self.RESIZE_MARGIN = 5  # 调整大小的边缘宽度

        # 设置无边框窗口
        self.setWindowFlags(QtCore.Qt.FramelessWindowHint)
        self.setAttribute(QtCore.Qt.WA_TranslucentBackground)  # 允许使用透明度

        self.setWindowTitle("VI OTR 报错统计工具")
        self.setGeometry(100, 100, 800, 600)

        # 创建主布局
        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)  # 设置主布局边距为0
        main_layout.setSpacing(0)  # 设置布局间距为0

        # 创建一个带圆角的容器widget
        container = QtWidgets.QWidget(self)
        container.setObjectName("container")
        container_layout = QtWidgets.QVBoxLayout(container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(0)

        # 创建标题栏
        title_bar = QtWidgets.QWidget()
        title_bar.setFixedHeight(30)
        title_bar.setStyleSheet("background-color: #2b2b2b;")

        title_layout = QtWidgets.QHBoxLayout(title_bar)
        title_layout.setContentsMargins(10, 0, 0, 0)

        # 添加标题文本
        title_label = QtWidgets.QLabel("VI OTR 报错统计工具")
        title_label.setStyleSheet("color: white; font-size: 12px;")

        # 创建窗口控制按钮
        btn_layout = QtWidgets.QHBoxLayout()
        btn_layout.setSpacing(0)

        self.minimize_button = QtWidgets.QPushButton()
        self.maximize_button = QtWidgets.QPushButton()
        self.close_button = QtWidgets.QPushButton()

        # 设置按钮图标
        self.minimize_button.setIcon(
            self.style().standardIcon(QtWidgets.QStyle.SP_TitleBarMinButton)
        )
        self.maximize_button.setIcon(
            self.style().standardIcon(QtWidgets.QStyle.SP_TitleBarMaxButton)
        )
        self.close_button.setIcon(
            self.style().standardIcon(QtWidgets.QStyle.SP_TitleBarCloseButton)
        )

        # 设置按钮大小
        for btn in (self.minimize_button, self.maximize_button, self.close_button):
            btn.setFixedSize(30, 30)
            btn.setStyleSheet(
                """
                QPushButton {
                    background-color: transparent;
                    border: none;
                }
                QPushButton:hover {
                    background-color: #404040;
                }
                QPushButton:pressed {
                    background-color: #505050;
                }
            """
            )

        self.close_button.setStyleSheet(
            """
            QPushButton {
                background-color: transparent;
                border: none;
            }
            QPushButton:hover {
                background-color: #e81123;
            }
            QPushButton:pressed {
                background-color: #f1707a;
            }
        """
        )

        # 添加按钮到布局
        title_layout.addWidget(title_label)
        title_layout.addStretch()
        title_layout.addWidget(self.minimize_button)
        title_layout.addWidget(self.maximize_button)
        title_layout.addWidget(self.close_button)

        # 创建内容区域
        content_widget = QtWidgets.QWidget()
        content_layout = QtWidgets.QVBoxLayout(content_widget)
        content_layout.setContentsMargins(
            10, 10, 10, 10
        )  # 设置内容区域的边距

        # 创建输入框和按钮
        input_widget = QtWidgets.QWidget()
        input_layout = QtWidgets.QVBoxLayout(input_widget)
        input_layout.setContentsMargins(0, 0, 0, 0)

        self.material_code_input = QtWidgets.QLineEdit(self)
        self.material_code_input.setPlaceholderText("请输入物料代码")
        self.position_input = QtWidgets.QLineEdit(self)
        self.position_input.setPlaceholderText("请输入位号")

        self.start_time_input = QtWidgets.QDateTimeEdit(self)
        self.start_time_input.setDisplayFormat("yyyy-MM-dd HH:mm")
        self.start_time_input.setDateTime(QtCore.QDateTime.currentDateTime())

        self.end_time_input = QtWidgets.QDateTimeEdit(self)
        self.end_time_input.setDisplayFormat("yyyy-MM-dd HH:mm")
        self.end_time_input.setDateTime(QtCore.QDateTime.currentDateTime().addSecs(-1))

        self.query_button = QtWidgets.QPushButton("查询", self)
        self.export_button = QtWidgets.QPushButton("导出为Excel", self)

        # 创建 QTableWidget 以显示查询结果
        self.result_table = QtWidgets.QTableWidget(self)
        self.result_table.setColumnCount(3)
        self.result_table.setHorizontalHeaderLabels(
            ['物料代码', '位号', '报警次数']
        )

        # 设置表格样式
        self.result_table.horizontalHeader().setStyleSheet(
            """
            QHeaderView {
                background-color: #333333;
            }
            QHeaderView::section {
                background-color: #333333;
                color: white;
                padding: 5px;
                border: 1px solid #555555;
            }
        """
        )

        self.result_table.verticalHeader().setStyleSheet(
            """
            QHeaderView, QHeaderView::section {
                background-color: #333333;
                color: white;
                border: 1px solid #555555;
            }
        """
        )

        # 确保垂直表头可见
        self.result_table.verticalHeader().setVisible(True)

        # 设置表格网格线颜色
        self.result_table.setStyleSheet(
            """
            QTableWidget {
                background-color: #404040;
                border: 1px solid #555555;
                gridline-color: #555555;
            }
            QTableWidget::item {
                color: white;
            }
        """
        )

        # 在现有代码的input_layout中添加线别选择
        line_layout = QtWidgets.QHBoxLayout()
        self.line_combo.clear()  # 清除可能存在的旧数据
        self.line_combo.addItems(self.lines_dict.keys())
        config_btn = QtWidgets.QPushButton("配置线别")
        config_btn.clicked.connect(self.show_line_config)
        
        line_layout.addWidget(QtWidgets.QLabel("选择线别:"))
        line_layout.addWidget(self.line_combo)
        line_layout.addWidget(config_btn)
        
        # 将line_layout添加到input_layout的最前面
        input_layout.insertLayout(0, line_layout)
        
        # 修改下拉框样式
        self.line_combo.setStyleSheet("""
            QComboBox {
                background-color: #404040;
                color: white;
                border: 1px solid #555555;
                padding: 5px;
                border-radius: 3px;
            }
            QComboBox::drop-down {
                border: none;
                background-color: #404040;
                width: 20px;
            }
            QComboBox::down-arrow {
                background: none;
                border: none;
                width: 12px;
                height: 12px;
            }
            QComboBox QAbstractItemView {
                background-color: #404040;
                color: white;
                selection-background-color: #0078D7;
                selection-color: white;
                border: 1px solid #555555;
            }
            QComboBox QAbstractItemView::item {
                padding: 5px;
            }
            QComboBox QAbstractItemView::item:hover {
                background-color: #505050;
            }
        """)

        # 设置下拉箭头图标
        self.line_combo.view().window().setWindowFlags(QtCore.Qt.Popup | QtCore.Qt.FramelessWindowHint | QtCore.Qt.NoDropShadowWindowHint)
        self.line_combo.view().window().setAttribute(QtCore.Qt.WA_TranslucentBackground)

        input_layout.addWidget(self.material_code_input)
        input_layout.addWidget(self.position_input)
        input_layout.addWidget(QtWidgets.QLabel("开始时间 (YYYY-MM-DD HH:mm):"))
        input_layout.addWidget(self.start_time_input)
        input_layout.addWidget(QtWidgets.QLabel("结束时间 (YYYY-MM-DD HH:mm):"))
        input_layout.addWidget(self.end_time_input)
        input_layout.addWidget(self.query_button)
        input_layout.addWidget(self.export_button)

        content_layout.addWidget(input_widget)
        content_layout.addWidget(self.result_table)

        # 将标题栏和内容区域添加到容器布局
        container_layout.addWidget(title_bar)
        container_layout.addWidget(content_widget)

        # 将容器添加到主布局
        main_layout.addWidget(container)

        # 连接按钮信号
        self.minimize_button.clicked.connect(self.showMinimized)
        self.maximize_button.clicked.connect(self.toggle_maximize)
        self.close_button.clicked.connect(self.close)

        # 添加查询和导出按钮的信号连接
        self.query_button.clicked.connect(self.query_errors)
        self.export_button.clicked.connect(self.export_to_excel)

        # 设置整体窗口样式
        self.setStyleSheet(
            """
            QWidget#container {
                background-color: #333333;
                border-radius: 5px;
            }
            QWidget {
                color: white;
                font-family: Arial, sans-serif;
            }
            QLineEdit, QDateTimeEdit {
                background-color: #404040;
                border: 1px solid #555555;
                padding: 5px;
                border-radius: 3px;
            }
            QPushButton {
                background-color: #0078D7;
                color: white;
                border: none;
                padding: 8px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #1884D7;
            }
            QTableWidget {
                background-color: #404040;
                border: 1px solid #555555;
                gridline-color: #555555;
            }
            QTableWidget::item {
                color: white;
            }
            QHeaderView {
                background-color: #333333;
            }
            QHeaderView::section {
                background-color: #333333;
                color: white;
                padding: 5px;
                border: 1px solid #555555;
            }
            QHeaderView::section:horizontal {
                background-color: #333333;
            }
            QHeaderView::section:vertical {
                background-color: #333333;
            }
        """
        )

    def toggle_maximize(self):
        if self.isMaximized():
            self.showNormal()
            self.maximize_button.setIcon(
                self.style().standardIcon(QtWidgets.QStyle.SP_TitleBarNormalButton)
            )
        else:
            self.showMaximized()
            self.maximize_button.setIcon(
                self.style().standardIcon(QtWidgets.QStyle.SP_TitleBarMaxButton)
            )

    def load_config(self):
        """加载配置文件，包含验证和默认值处理"""
        try:
            config = configparser.ConfigParser()
            lines_dict = {}

            if os.path.exists(CONFIG_FILE):
                config.read(CONFIG_FILE, encoding='utf-8')
                # 读取所有线别和路径
                if 'Lines' in config:
                    raw_lines = dict(config['Lines'])

                    # 验证每个路径的有效性
                    for line_name, path in raw_lines.items():
                        if path and os.path.exists(path) and os.path.isdir(path):
                            lines_dict[line_name] = path
                        else:
                            print(f"警告：线别 '{line_name}' 的路径无效或不存在: {path}")

            # 如果没有有效配置，提供默认提示
            if not lines_dict:
                print("未找到有效的线别配置，需要手动配置")

            return lines_dict

        except configparser.Error as e:
            print(f"配置文件格式错误: {str(e)}")
            return {}
        except Exception as e:
            print(f"加载配置文件出错: {str(e)}")
            return {}

    def save_config(self, lines_dict):
        try:
            config = configparser.ConfigParser()
            config['Lines'] = lines_dict
            with open(CONFIG_FILE, 'w', encoding='utf-8') as configfile:
                config.write(configfile)
        except Exception as e:
            print(f"保存配置文件出错: {str(e)}")
            QtWidgets.QMessageBox.warning(self, "警告", f"保存配置文件失败: {str(e)}")

    def show_file_path_selection(self):
        # 获取当前选中线别的路径作为初始路径
        current_line = self.line_combo.currentText()
        initial_path = self.lines_dict.get(current_line, "")
        
        dialog = FilePathSelectionDialog(initial_path)
        result = dialog.exec_()
        if result == QtWidgets.QDialog.Accepted:
            new_path = dialog.file_path_input.text().strip()
            # 更新当前线别的路径
            if current_line:
                self.lines_dict[current_line] = new_path
                self.save_config(self.lines_dict)
            return True
        return False
    
    def show_line_config(self):
        dialog = LineConfigDialog(self.lines_dict)
        if dialog.exec_() == QtWidgets.QDialog.Accepted:
            # 更新线别字典
            self.lines_dict = dialog.lines_dict
            self.save_config(self.lines_dict)
            
            # 立即更新下拉框
            current_text = self.line_combo.currentText()  # 保存当前选择
            self.line_combo.clear()
            self.line_combo.addItems(self.lines_dict.keys())
            
            # 如果之前选择的线别还存在，则保持选择
            index = self.line_combo.findText(current_text)
            if index >= 0:
                self.line_combo.setCurrentIndex(index)
            # 如果有线别，但之前的选择不存在了，则选择第一个
            elif self.line_combo.count() > 0:
                self.line_combo.setCurrentIndex(0)

    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.LeftButton:
            if event.pos().y() <= 30:  # 标题栏拖动
                self.is_dragging = True
                self.drag_position = event.globalPos() - self.frameGeometry().topLeft()
            else:  # 检查是否在边缘开始调整大小
                edge = self.get_resize_edge(event.pos())
                if edge:
                    self.resizing = True
                    self.resize_edge = edge
                    self.resize_start_pos = event.globalPos()
                    self.start_geometry = self.geometry()

    def mouseMoveEvent(self, event):
        if self.is_dragging:
            self.move(event.globalPos() - self.drag_position)
        elif self.resizing:
            self.resize_window(event.globalPos())
        else:
            # 更新鼠标样式
            edge = self.get_resize_edge(event.pos())
            if edge:
                if edge in ["left", "right"]:
                    self.setCursor(QtCore.Qt.SizeHorCursor)
                elif edge in ["top", "bottom"]:
                    self.setCursor(QtCore.Qt.SizeVerCursor)
                elif edge in ["topleft", "bottomright"]:
                    self.setCursor(QtCore.Qt.SizeFDiagCursor)
                elif edge in ["topright", "bottomleft"]:
                    self.setCursor(QtCore.Qt.SizeBDiagCursor)
            else:
                self.setCursor(QtCore.Qt.ArrowCursor)

    def mouseReleaseEvent(self, event):
        if event.button() == QtCore.Qt.LeftButton:
            self.is_dragging = False
            self.resizing = False
            self.resize_edge = None

    def get_resize_edge(self, pos):
        x = pos.x()
        y = pos.y()
        width = self.width()
        height = self.height()

        if y <= self.RESIZE_MARGIN:  # 上边缘
            if x <= self.RESIZE_MARGIN:
                return "topleft"
            elif x >= width - self.RESIZE_MARGIN:
                return "topright"
            return "top"
        elif y >= height - self.RESIZE_MARGIN:  # 下边缘
            if x <= self.RESIZE_MARGIN:
                return "bottomleft"
            elif x >= width - self.RESIZE_MARGIN:
                return "bottomright"
            return "bottom"
        elif x <= self.RESIZE_MARGIN:  # 左边缘
            return "left"
        elif x >= width - self.RESIZE_MARGIN:  # 右边缘
            return "right"
        return None

    def resize_window(self, global_pos):
        if not self.resize_edge:
            return

        diff = global_pos - self.resize_start_pos
        new_geometry = QtCore.QRect(self.start_geometry)

        if self.resize_edge in ["left", "topleft", "bottomleft"]:
            new_geometry.setLeft(self.start_geometry.left() + diff.x())
        if self.resize_edge in ["right", "topright", "bottomright"]:
            new_geometry.setRight(self.start_geometry.right() + diff.x())
        if self.resize_edge in ["top", "topleft", "topright"]:
            new_geometry.setTop(self.start_geometry.top() + diff.y())
        if self.resize_edge in ["bottom", "bottomleft", "bottomright"]:
            new_geometry.setBottom(self.start_geometry.bottom() + diff.y())

        # 设置最小尺寸
        if new_geometry.width() >= 400 and new_geometry.height() >= 300:
            self.setGeometry(new_geometry)

    def query_errors(self):
        # 如果正在查询,直接返回
        if self._is_querying:
            QtWidgets.QMessageBox.warning(self, "提示", "查询正在进行中,请等待当前查询完成")
            return

        try:
            # 设置查询状态
            self._is_querying = True

            # 禁用查询按钮
            self.query_button.setEnabled(False)

            # 移除阻塞的文件数量预检查，直接进入查询流程
            
            # 检查时间范围
            start_time = self.start_time_input.dateTime()
            end_time = self.end_time_input.dateTime()
            
            # 计算时间差(天数)
            days_diff = start_time.daysTo(end_time)
            
            # 修改时间范围检查的对话框样式
            if days_diff < 0:
                msg_box = QtWidgets.QMessageBox(self)
                msg_box.setIcon(QtWidgets.QMessageBox.Warning)
                msg_box.setWindowTitle("警告")
                msg_box.setText("结束时间不能早于开始时间")
                msg_box.setStyleSheet("""
                    QMessageBox {
                        background-color: #333333;
                    }
                    QMessageBox QLabel {
                        color: white;
                        font-size: 12px;
                        padding: 10px;
                    }
                    QPushButton {
                        background-color: #0078D7;
                        color: white;
                        border: none;
                        padding: 8px;
                        border-radius: 3px;
                        min-width: 80px;
                    }
                    QPushButton:hover {
                        background-color: #1884D7;
                    }
                """)
                msg_box.exec_()
                return
            
            # 修改时间范围提示对话框样式
            if days_diff > 30:
                msg_box = QtWidgets.QMessageBox(self)
                msg_box.setIcon(QtWidgets.QMessageBox.Question)
                msg_box.setWindowTitle("提示")
                msg_box.setText(f"您选择的时间范围为{days_diff}天,查询时间可能较长,是否继续?")
                msg_box.setStandardButtons(
                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
                )
                msg_box.setStyleSheet("""
                    QMessageBox {
                        background-color: #333333;
                    }
                    QMessageBox QLabel {
                        color: white;
                        font-size: 12px;
                        padding: 10px;
                    }
                    QPushButton {
                        background-color: #0078D7;
                        color: white;
                        border: none;
                        padding: 8px;
                        border-radius: 3px;
                        min-width: 80px;
                    }
                    QPushButton:hover {
                        background-color: #1884D7;
                    }
                """)
                reply = msg_box.exec_()
                if reply == QtWidgets.QMessageBox.No:
                    return
            
            current_line = self.line_combo.currentText()

            if not current_line or current_line not in self.lines_dict:
                msg_box = QtWidgets.QMessageBox(self)
                msg_box.setIcon(QtWidgets.QMessageBox.Warning)
                msg_box.setWindowTitle("错误")
                msg_box.setText("请选择有效的线别!")
                msg_box.setStyleSheet("""
                    QMessageBox {
                        background-color: #333333;
                    }
                    QMessageBox QLabel {
                        color: white;
                        font-size: 12px;
                        padding: 10px;
                    }
                    QPushButton {
                        background-color: #0078D7;
                        color: white;
                        border: none;
                        padding: 8px;
                        border-radius: 3px;
                        min-width: 80px;
                    }
                    QPushButton:hover {
                        background-color: #1884D7;
                    }
                """)
                msg_box.exec_()
                return
            
            folder_path = self.lines_dict[current_line]

            # 添加网络路径和活跃目录警告
            if is_network_path(folder_path):
                msg_box = QtWidgets.QMessageBox(self)
                msg_box.setIcon(QtWidgets.QMessageBox.Warning)
                msg_box.setWindowTitle("网络路径警告")
                msg_box.setText(f"检测到网络路径:\n{folder_path}\n\n访问网络路径可能会导致程序响应变慢，特别是当目标文件夹正在被其他程序使用时。\n\n是否继续?")
                msg_box.setStandardButtons(QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
                msg_box.setStyleSheet(self._get_message_box_style())
                reply = msg_box.exec_()
                if reply == QtWidgets.QMessageBox.No:
                    return

            # 移除活跃目录检查，避免UI阻塞
            
            # 检查路径是否存在
            if not os.path.exists(folder_path):
                QtWidgets.QMessageBox.warning(
                    self,
                    "错误",
                    f"选择的路径不存在:\n{folder_path}"
                )
                return

            # 检查是否为目录
            if not os.path.isdir(folder_path):
                QtWidgets.QMessageBox.warning(
                    self,
                    "错误",
                    f"选择的路径不是一个目录:\n{folder_path}"
                )
                return

            material_code = self.material_code_input.text().strip()
            position = self.position_input.text().strip()

            # 立即创建并显示进度对话框，避免任何UI阻塞
            self._progress_dialog = ProgressDialog(None, None)
            self._progress_dialog.status_label.setText("正在准备查询...")
            self._progress_dialog.detail_label.setText("正在初始化，请稍候...")
            self._progress_dialog.progress_bar.setRange(0, 0)  # 设置为不确定进度
            self._progress_dialog.show()

            # 强制处理UI事件，确保进度对话框立即显示
            QtWidgets.QApplication.processEvents()

            # 创建新的 worker 和线程
            self._worker = QueryWorker()
            self._worker_thread = QtCore.QThread()

            # 更新进度对话框的worker引用
            self._progress_dialog.worker = self._worker
            self._progress_dialog.worker_thread = self._worker_thread
            self._progress_dialog.cancelled.connect(self.cancel_query)
            self._progress_dialog.connect_worker_signals()  # 连接worker信号

            # 连接信号（使用Qt.UniqueConnection避免重复连接）
            self._worker.finished.connect(self._on_query_finished, QtCore.Qt.UniqueConnection)
            self._worker.result.connect(self.handle_query_result, QtCore.Qt.UniqueConnection)
            self._worker.error.connect(self.handle_query_error, QtCore.Qt.UniqueConnection)

            # 连接清理信号
            self._worker_thread.finished.connect(self._worker_thread.deleteLater, QtCore.Qt.UniqueConnection)

            # 移动 worker 到线程
            self._worker.moveToThread(self._worker_thread)

            # 连接启动信号并使用正确的时间格式
            # 将QDateTime转换为时间戳，避免字符串格式问题
            start_timestamp = start_time.toSecsSinceEpoch()
            end_timestamp = end_time.toSecsSinceEpoch()

            self._worker_thread.started.connect(
                lambda: self._worker.do_query(
                    folder_path,
                    material_code,
                    start_timestamp,
                    end_timestamp,
                    position
                )
            )

            # 更新进度对话框状态并启动查询
            self._progress_dialog.status_label.setText("正在启动查询...")
            self._progress_dialog.detail_label.setText("正在启动后台处理线程...")
            QtWidgets.QApplication.processEvents()

            # 启动查询
            self._worker_thread.start()
            
        except Exception as e:
            # 关闭进度对话框
            if hasattr(self, '_progress_dialog') and self._progress_dialog:
                self._progress_dialog.close()
                self._progress_dialog = None

            QtWidgets.QMessageBox.critical(self, "错误", f"启动查询时发生错误: {str(e)}")
            # 在异常情况下重置状态
            self._is_querying = False
            self.query_button.setEnabled(True)

    def _cleanup_thread(self):
        """增强的线程和资源清理"""
        cleanup_success = True

        try:
            # 1. 首先取消worker操作
            if self._worker is not None:
                try:
                    self._worker.cancel()
                    print("Worker已取消")
                except Exception as e:
                    print(f"取消worker时出错: {str(e)}")
                    cleanup_success = False

            # 2. 清理线程
            if self._worker_thread is not None and self._worker_thread.isRunning():
                print("正在停止工作线程...")

                # 请求线程退出
                self._worker_thread.quit()

                # 等待线程完成,设置超时
                if not self._worker_thread.wait(5000):  # 增加到5秒
                    print("警告:线程未能正常退出，尝试强制终止")
                    self._worker_thread.terminate()
                    if not self._worker_thread.wait(2000):  # 再等2秒
                        print("错误:线程强制终止失败")
                        cleanup_success = False
                    else:
                        print("线程已强制终止")
                else:
                    print("线程已正常退出")

            # 3. 清理对象引用
            if self._worker is not None:
                try:
                    # 断开所有信号连接
                    self._worker.finished.disconnect()
                    self._worker.result.disconnect()
                    self._worker.error.disconnect()
                    self._worker.status_update.disconnect()
                except Exception:
                    pass  # 忽略断开连接的错误

                self._worker.deleteLater()
                self._worker = None
                print("Worker对象已清理")

            if self._worker_thread is not None:
                self._worker_thread.deleteLater()
                self._worker_thread = None
                print("线程对象已清理")

            # 4. 强制垃圾回收和内存优化
            import gc
            collected = gc.collect()
            if collected > 0:
                print(f"垃圾回收清理了 {collected} 个对象")

            if cleanup_success:
                print("资源清理完成")
            else:
                print("资源清理完成，但存在一些问题")

        except Exception as e:
            print(f"清理线程时发生错误: {str(e)}")
            # 确保变量被重置
            self._worker = None
            self._worker_thread = None

    def _cleanup_worker(self):
        """清理worker对象"""
        try:
            if self._worker is not None:
                # 确保worker在主线程
                if self._worker.thread() != QtCore.QThread.currentThread():
                    self._worker.moveToThread(QtCore.QThread.currentThread())
                self._worker.deleteLater()
                self._worker = None
        except Exception as e:
            print(f"清理worker时发生错误: {str(e)}")
            self._worker = None

    def _on_query_finished(self):
        """查询完成的处理"""
        try:
            print("Query finished signal received")
            
            # 先关闭进度对话框
            if self._progress_dialog:
                self._progress_dialog.program_closing = True
                self._progress_dialog.close()
                self._progress_dialog = None
                
            # 最后清理线程
            self._cleanup_thread()
            
        except Exception as e:
            print(f"查询完成处理时发生错误: {str(e)}")
        finally:
            self._is_querying = False
            self.query_button.setEnabled(True)

    def cancel_query(self):
        """取消查询操作，增强版"""
        try:
            # 立即显示取消中提示
            if self._progress_dialog:
                self._progress_dialog.status_label.setText("正在取消操作...")
                self._progress_dialog.detail_label.setText("请稍候，正在终止所有操作...")
                QtWidgets.QApplication.processEvents()  # 强制处理事件，确保UI更新
            
            if self._worker:
                self._worker.cancel()
                
            # 如果线程在超时后仍无法终止，则强制结束
            killed = False
            if self._worker_thread and self._worker_thread.isRunning():
                self._worker_thread.quit()
                if not self._worker_thread.wait(3000):  # 等待3秒
                    self._worker_thread.terminate()     # 强制终止
                    killed = True
            
            if self._progress_dialog:
                self._progress_dialog.close()
                self._progress_dialog = None
            
            if killed:
                QtWidgets.QMessageBox.warning(self, "警告", "查询操作已强制终止，可能需要重启程序以恢复正常状态。")
            else:
                QtWidgets.QMessageBox.information(self, "提示", "查询已取消")
            
        finally:
            self._is_querying = False
            self.query_button.setEnabled(True)

    def handle_query_result(self, count_dict):
        # 更新表格列数
        self.result_table.setColumnCount(4)
        self.result_table.setHorizontalHeaderLabels(
            ['物料代码', '位号', '报警次数', '占比(%)']
        )
        
        # 检查是否有结果
        if not count_dict:
            msg_box = QtWidgets.QMessageBox(self)
            msg_box.setIcon(QtWidgets.QMessageBox.Information)
            msg_box.setWindowTitle("提示")
            msg_box.setText("未找到符合条件的数据")
            
            # 修改MessageBox样式,确保文本可见
            msg_box.setStyleSheet("""
                QMessageBox {
                    background-color: #333333;
                }
                QMessageBox QLabel {
                    color: white;
                    font-size: 12px;
                    padding: 10px;
                }
                QPushButton {
                    background-color: #0078D7;
                    color: white;
                    border: none;
                    padding: 8px;
                    border-radius: 3px;
                    min-width: 80px;
                }
                QPushButton:hover {
                    background-color: #1884D7;
                }
            """)
            
            msg_box.exec_()
            self.result_table.setRowCount(0)
            return
        
        # 隐藏行头（垂直表头）
        self.result_table.verticalHeader().setVisible(False)
        
        # 计算总数
        total_count = sum(count_dict.values())
        
        # 按报警次数排序
        sorted_items = sorted(
            count_dict.items(),
            key=lambda x: x[1],
            reverse=True
        )
        
        # 清空表格
        self.result_table.setRowCount(0)
        
        # 填充数据
        for (material_code, position), count in sorted_items:
            row = self.result_table.rowCount()
            self.result_table.insertRow(row)
            
            # 计算百分比
            percentage = (count / total_count * 100) if total_count > 0 else 0
            
            # 设置单元格数据
            self.result_table.setItem(row, 0, 
                QtWidgets.QTableWidgetItem(str(material_code)))
            self.result_table.setItem(row, 1, 
                QtWidgets.QTableWidgetItem(str(position)))
            self.result_table.setItem(row, 2, 
                QtWidgets.QTableWidgetItem(str(count)))
            self.result_table.setItem(row, 3,
                QtWidgets.QTableWidgetItem(f"{percentage:.2f}%"))

        # 保存导出数据,包含百分比
        self.export_data = {
            'items': sorted_items,
            'total': total_count
        }

    def handle_query_error(self, error_msg):
        """处理查询错误"""
        try:
            # 清理线程
            self._cleanup_thread()
            
            # 关闭进度对话框
            if self._progress_dialog:
                self._progress_dialog.program_closing = True
                self._progress_dialog.close()
                self._progress_dialog = None
            
            # 创建错误对话框
            error_dialog = QtWidgets.QDialog(self)
            error_dialog.setWindowTitle("错误信息")
            error_dialog.setMinimumWidth(500)
            error_dialog.setMinimumHeight(300)
            
            layout = QtWidgets.QVBoxLayout(error_dialog)
            
            # 添加错误信息文本框
            text_edit = QtWidgets.QTextEdit()
            text_edit.setReadOnly(True)
            text_edit.setPlainText(error_msg)
            layout.addWidget(text_edit)
            
            # 添加关闭按钮
            close_button = QtWidgets.QPushButton("关闭")
            close_button.clicked.connect(error_dialog.close)
            layout.addWidget(close_button)
            
            # 设置样式
            error_dialog.setStyleSheet("""
                QDialog {
                    background-color: #333333;
                    color: white;
                }
                QTextEdit {
                    background-color: #404040;
                    color: white;
                    border: 1px solid #555555;
                    font-family: Consolas, Monospace;
                }
                QPushButton {
                    background-color: #0078D7;
                    color: white;
                    border: none;
                    padding: 8px;
                    border-radius: 3px;
                }
                QPushButton:hover {
                    background-color: #1884D7;
                }
            """)
            
            # 显示对话框
            error_dialog.exec_()
            
        finally:
            # 确保重置状态
            self._is_querying = False
            self.query_button.setEnabled(True)

    def export_to_excel(self):
        if not hasattr(self, 'export_data') or not self.export_data:
            QtWidgets.QMessageBox.warning(self, "警告", "没有可导出的数据！")
            return
            
        # 获取导出格式
        formats = {
            'Excel (*.xlsx)': self._export_excel,
            'CSV (*.csv)': self._export_csv,
            'HTML (*.html)': self._export_html
        }
        
        format_str, _ = QtWidgets.QFileDialog.getSaveFileName(
            self, 
            "保存文件", 
            "", 
            ";;".join(formats.keys())
        )
        
        if not format_str:
            return
            
        try:
            # 调用对应的导出函数
            exported = False
            for fmt, func in formats.items():
                if fmt in format_str:
                    func(format_str)
                    exported = True
                    break

            if exported:
                QtWidgets.QMessageBox.information(self, "成功", "导出成功！")
            else:
                QtWidgets.QMessageBox.warning(self, "警告", "未知的文件格式！")
            
        except Exception as e:
            QtWidgets.QMessageBox.critical(
                self,
                "错误",
                f"导出失败: {str(e)}"
            )
            
    def _export_excel(self, file_path):
        """导出为Excel格式"""
        df = self._get_export_dataframe()
        df.to_excel(file_path, index=False)
        
    def _export_csv(self, file_path):
        """导出为CSV格式"""
        df = self._get_export_dataframe()
        df.to_csv(file_path, index=False, encoding='utf-8-sig')  # 添加BOM以支持中文
        
    def _export_html(self, file_path):
        """导出为HTML格式"""
        df = self._get_export_dataframe()
        df.to_html(file_path, index=False)
        
    def _get_export_dataframe(self):
        """获取要导出的数据框"""
        sorted_items = self.export_data['items']
        total_count = self.export_data['total']
        
        # 构建导出数据,包含更多统计信息
        export_list = []
        cumulative_count = 0
        for (material_code, position), count in sorted_items:
            percentage = (count/total_count*100)
            cumulative_count += count
            cumulative_percentage = (cumulative_count/total_count*100)

            export_list.append({
                '物料代码': material_code,
                '位号': position,
                '报警次数': count,
                '占比(%)': f"{percentage:.2f}%",
                '累计占比(%)': f"{cumulative_percentage:.2f}%"
            })
            
        return pd.DataFrame(export_list)

    def closeEvent(self, event):
        """窗口关闭事件处理"""
        try:
            self._cleanup_thread()
            event.accept()
        except Exception as e:
            print(f"关闭窗口时发生错误: {str(e)}")
            event.accept()

    def _get_message_box_style(self):
        return """
            QMessageBox {
                background-color: #333333;
            }
            QMessageBox QLabel {
                color: white;
                font-size: 12px;
                padding: 10px;
            }
            QPushButton {
                background-color: #0078D7;
                color: white;
                border: none;
                padding: 8px;
                border-radius: 3px;
                min-width: 80px;
            }
            QPushButton:hover {
                background-color: #1884D7;
            }
        """

    def show_message(self, title, text, icon=QtWidgets.QMessageBox.Information):
        msg_box = QtWidgets.QMessageBox(self)
        msg_box.setIcon(icon)
        msg_box.setWindowTitle(title)
        msg_box.setText(text)
        msg_box.setStyleSheet(self._get_message_box_style())
        return msg_box.exec_()

    def _check_directory_active_async(self, path):
        """异步检查目录活跃状态，避免阻塞UI"""
        def check_active():
            try:
                print(f"检查目录活跃状态: {path}")

                # 快速检查：只检查根目录的前50个文件
                initial_files = {}
                try:
                    files = os.listdir(path)[:50]  # 只检查前50个文件
                    for file in files:
                        if file.endswith('.otr'):
                            file_path = os.path.join(path, file)
                            try:
                                stat_info = os.stat(file_path)
                                initial_files[file_path] = (stat_info.st_mtime, stat_info.st_size)
                            except (OSError, PermissionError):
                                continue
                except Exception as e:
                    print(f"获取初始文件状态失败: {str(e)}")
                    return False

                # 短暂等待
                time.sleep(1)

                # 再次检查
                current_files = {}
                try:
                    files = os.listdir(path)[:50]
                    for file in files:
                        if file.endswith('.otr'):
                            file_path = os.path.join(path, file)
                            try:
                                stat_info = os.stat(file_path)
                                current_files[file_path] = (stat_info.st_mtime, stat_info.st_size)
                            except (OSError, PermissionError):
                                continue
                except Exception as e:
                    print(f"获取当前文件状态失败: {str(e)}")
                    return False

                # 检查是否有变化
                if len(current_files) != len(initial_files):
                    return True

                for file_path, (mtime, size) in current_files.items():
                    if file_path not in initial_files:
                        return True
                    if initial_files[file_path] != (mtime, size):
                        return True

                return False

            except Exception as e:
                print(f"检查目录活跃状态时出错: {str(e)}")
                return False

        # 在后台线程中执行检查
        def background_check():
            is_active = check_active()
            if is_active:
                # 使用QTimer在主线程中显示警告
                QtCore.QTimer.singleShot(0, lambda: self._show_active_directory_warning(path))

        thread = threading.Thread(target=background_check, daemon=True)
        thread.start()

    def _show_active_directory_warning(self, path):
        """在主线程中显示活跃目录警告"""
        msg_box = QtWidgets.QMessageBox(self)
        msg_box.setIcon(QtWidgets.QMessageBox.Warning)
        msg_box.setWindowTitle("活跃目录警告")
        msg_box.setText(f"检测到目标目录正在活跃使用中（有文件正在创建/修改）:\n{path}\n\n这可能会影响查询性能和准确性。建议：\n1. 等待文件生成完成后再查询\n2. 或者选择一个较小的时间范围\n\n提示：您可以继续查询，程序已优化处理活跃目录。")
        msg_box.setStandardButtons(QtWidgets.QMessageBox.Ok)
        msg_box.setStyleSheet(self._get_message_box_style())
        msg_box.exec_()

    def _quick_file_count_check(self, path):
        """快速检查文件数量，给用户提示但不阻止查询"""
        try:
            file_count = 0
            max_check = 2000  # 提高检查数量，适应几个月的文件

            for root, dirs, files in os.walk(path):
                # 限制检查深度
                depth = root[len(path):].count(os.sep)
                if depth >= 5:  # 适当增加深度
                    dirs[:] = []
                    continue

                for filename in files:
                    if filename.endswith('.otr'):
                        file_count += 1
                        if file_count >= max_check:
                            break

                if file_count >= max_check:
                    break

            # 如果发现大量文件，只给出提示，不阻止查询
            if file_count >= max_check:
                msg_box = QtWidgets.QMessageBox(self)
                msg_box.setIcon(QtWidgets.QMessageBox.Information)
                msg_box.setWindowTitle("大量文件提示")
                msg_box.setText(f'检测到目录中有大量文件（超过{max_check}个.otr文件）。\n\n'
                               '程序将开始处理，请耐心等待进度条显示。\n'
                               '处理过程中请不要关闭程序。')
                msg_box.setStandardButtons(QtWidgets.QMessageBox.Ok)
                msg_box.setStyleSheet(self._get_message_box_style())
                msg_box.exec_()

            return False  # 永远不取消查询，只是提示

        except Exception:
            return False  # 检查失败时不阻止查询

def is_network_path(path):
    """
    检测路径是否为网络路径
    
    参数:
        path: 要检查的路径
        
    返回:
        bool: 如果是网络路径返回True，否则返回False
    """
    import platform
    import os
    
    # 去除路径两端的空格
    path = path.strip()
    
    # Windows系统下的网络路径检测
    if platform.system() == "Windows":
        # UNC路径 (以\\开头)
        if path.startswith('\\\\'):
            return True
        
        # 检查是否为映射的网络驱动器
        # 只获取驱动器字母(例如从"C:\path"中获取"C:")
        if len(path) > 1 and path[1] == ':':
            drive = path[0].upper() + ':'
            try:
                import win32api
                import win32con
                drive_type = win32api.GetDriveType(drive)
                if drive_type == win32con.DRIVE_REMOTE:
                    return True
            except ImportError:
                # 如果没有win32api模块，使用简单的cmd命令判断
                try:
                    import subprocess
                    # 使用net use命令获取映射的网络驱动器
                    result = subprocess.run('net use', shell=True, capture_output=True, text=True)
                    return drive.lower() in result.stdout.lower()
                except:
                    pass
    
    # Linux/Mac系统下的网络路径检测
    else:
        # 检查是否为NFS或SMB挂载点
        if os.path.ismount(path):
            try:
                import subprocess
                # 使用mount或df命令检查
                result = subprocess.run(['mount'], capture_output=True, text=True)
                if path in result.stdout and ('nfs' in result.stdout or 'smbfs' in result.stdout or 'cifs' in result.stdout):
                    return True
            except:
                pass
    
    return False

# 添加网络连接检测函数
def check_network_connection(path):
    """检查网络连接状态"""
    if not is_network_path(path):
        return True
        
    # 尝试快速访问路径，检测是否可达
    try:
        # 使用超时设置运行简单命令
        import subprocess
        import platform
        
        if platform.system() == "Windows":
            # Windows上使用dir命令
            process = subprocess.run(
                f'dir "{path}" /B /A:-D',
                shell=True,
                capture_output=True,
                timeout=5
            )
            return process.returncode == 0
        else:
            # Linux/Mac上使用ls命令
            process = subprocess.run(
                f'ls -la "{path}" | head -n 1',
                shell=True,
                capture_output=True,
                timeout=5
            )
            return process.returncode == 0
    except:
        return False

if __name__ == "__main__":
    try:
        app = QtWidgets.QApplication([])
        window = OTRStatisticsApp()
        window.show()
        app.exec_()
    except Exception as e:
        # 显示错误对话框
        error_dialog = QtWidgets.QMessageBox()
        error_dialog.setIcon(QtWidgets.QMessageBox.Critical)
        error_dialog.setWindowTitle("错误")
        error_dialog.setText("程序启动时发生错误")
        error_dialog.setDetailedText(str(e))
        error_dialog.exec_()
